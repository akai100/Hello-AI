在使用多进程处理与加速器时，可能会出现一个称为“有害分叉”的已知问题。

当加速器的运行时不安全且在进程分叉前已初始化时，就会出现这种情况，从而导致子进程中出现运行时错误。

```
1. 问题本质:

“有害分叉（Poison fork）” 是多进程与硬件加速器（如 GPU、Intel GPU 等）配合使用时的运行时兼容性问题，
核心是 “加速器运行时” 与 “进程分叉（fork）” 的时序冲突导致子进程异常。

2. 关键触发条件（两个缺一不可）

（1）加速器运行时本身不支持 “fork” 安全（即该运行时的设计不兼容进程分叉机制）；

（2）主进程在创建（分叉）子进程之前，已经提前初始化了该加速器的运行时（比如提前加载 CUDA 运行环境、初始化 GPU 设备）。

3. 最终结果

子进程无法正常工作，抛出运行时错误（如设备初始化失败、资源占用冲突等），导致多进程任务异常终止。

4. 通俗类比

可以把加速器运行时理解为 “一套专用工具组”，主进程提前打开并占用了这套工具（初始化运行时），
但这套工具不支持 “复制共享”（非 fork 安全）。

当主进程fork子进程时，试图给子进程也复制一套 “半打开、已占用” 的工具，导致子进程无法正常使用工具（运行时错误），
这就是 “有害fork”。

5. 核心解决思路

（1）推迟初始化：不在主进程提前初始化加速器，而是等到子进程创建完成后，在每个子进程内部单独初始化加速器运行时；

（2）更换启动方式：放弃fork（分叉）模式，使用spawn或forkserver模式启动子进程，这两种模式会为每个子进程创建“干净的运行环境”，
避免继承主进程已初始化的不安全加速器运行时。
```

为防止此类错误：

+ 避免在主进程中初始化加速器后再派生子进程。

+ 使用替代的进程启动方法，例如```spawn```或```forkserver```，这能确保每个进程的干净初始化。
