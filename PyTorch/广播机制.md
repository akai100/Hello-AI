# 1. 通用机制

如果满足以下规则，则两个张量是“可广播的”：

+ 每个张量至少有一个维度；

+ 在遍历维度大小时，从最后一个维度开始，维度大小要么相等，要么其中一个为1，要么其中一个不存在；

```python3
x = torch.empty(5, 4, 3, 1)
y = torch.empty(   3, 2, 1)
# x 和 y 是可广播的
```

如果两个张量```x```和```y```是可广播的，则结果张量的大小按以下方式计算：

+ 如果x和y的维度数量不相等，就在维度较少的张量的维度前添加1，使它们的长度相等；

+ 然后，对于每个维度大小，得到的维度大小是该维度上x和y的大小的最大值

```python3
>>> x=torch.empty(5,1,4,1)
>>> y=torch.empty(  3,1,1)
>>> (x+y).size()
torch.Size([5, 3, 4, 1])
```

# 2. 原地

一个复杂情况是，就地操作不允许就地张量因广播而改变形状。

```python3
x=torch.empty(5,3,4,1)
y=torch.empty(3,1,1)
(x.add_(y)).size()
# torch.Size([5, 3, 4, 1])

# but:
x=torch.empty(1,3,1)
y=torch.empty(3,1,7)
(x.add_(y)).size()
# RuntimeError: The expanded size of the tensor (1) must match the existing size (7) at non-singleton dimension 2.
```
# 3. 向后兼容性


