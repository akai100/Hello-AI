
使用图表提交工作分为三个不同的阶段：定义、实例化和执行。

+ 在定义或创建阶段，程序会创建图表中操作的描述以及这些操作之间的依赖关系。

+ 实例化会对图形模板进行快照、验证，并执行大量设置和初始化工作，目的是最大限度地减少启动时需要完成的任务。由此产生的实例被称为可执行图形。

## 1. 图的创建

可以通过两种机制创建图：使用显式的图API和通过流捕获。

### 1.1 图编程接口

以下是创建下图的示例（省略了声明和其他样板代码）。请注意使用cudaGraphCreate()创建图，以及使用cudaGraphAddNode()添加内核节点及其依赖项。

```C++
cudaGraphCreate(&graph, 0);

cudaGraphNode_t nodes[4];

```

### 1.2 流捕获

流捕获提供了一种从现有基于流的API创建图的机制。一段将工作加载到流中的代码（包括现有代码）可以用```cudaStreamBeginCapture()```和```cudaStreamEndCapture()```的调用括起来。

```c++
cudaGraph_t graph;

cudaStreamBeginCapture(stream);

kernel_A<<< ..., stream >>>(...);
kernel_B<<< ..., stream >>>(...);
libraryCall(stream);
kernel_C<<< ..., stream >>>(...);

cudaStreamEndCapture(stream, &graph);
```

调用```cudaStreamBeginCapture()```会将流置于**捕获模式**。当流处于捕获状态时，启动到该流中的工作不会被排入执行队列。相反，这些工作会被附加到一个正在逐步构建的内部图中。

然后，通过调用```cudaStreamEndCapture()```可以返回该图，此调用还会结束流的捕获模式。由流捕获主动构建的图被称为**捕获图**。

流捕获可用于任何 CUDA 流，但不包括```cudaStreamLegacy```（即“NULL流”）。请注意，它可以用于```cudaStreamPerThread```。如果程序正在使用传统流，
可能可以将流0重新定义为每线程流，而不会产生功能变化。

可以使用```cudaStreamIsCapturing()```查询流是否正在被捕获。

可以使用```cudaStreamBeginCaptureToGraph()```将工作捕获到现有图中。与捕获到内部图不同，工作会被捕获到用户提供的图中。

#### 1.2.1 跨流依赖关系和事件

流捕获可以处理通过```cudaEventRecord()```和```cudaStreamWaitEvent()```表达的跨流依赖关系，前提是所等待的事件已记录到同一个捕获图中。

当事件被记录在处于捕获模式的流中时，就会产生一个捕获的事件。捕获的事件表示捕获图中的一组节点。

当一个捕获的事件被流等待时，如果该流尚未处于捕获模式，它会将其置于捕获模式，并且流中的下一个项目将对捕获事件中的节点具有额外的依赖关系。
这两个流随后会被捕获到同一个捕获图中。
