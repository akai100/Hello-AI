
CUDA 用户对象可用于帮助管理 CUDA 中异步工作所使用资源的生命周期。特别是，对于 CUDA 图和流捕获非常有用。

```
CUDA 异步操作（流执行、图捕获 / 启动）的特点是：CPU 发起操作后立即返回，GPU 异步执行。若异步操作依赖的
资源（如主机内存、自定义缓冲区）被 CPU 提前释放，会导致 GPU 访问非法内存，引发崩溃或数据错误。

而用户对象让 CUDA 运行时自动管理资源生命周期 —— 仅当所有关联的异步操作完成后，才触发资源的销毁逻辑。
```

各种资源管理方案与 CUDA 图不兼容。例如，基于事件的池或同步创建、异步销毁的方案。

```
CUDA 图的本质：它是对 CUDA 操作的 “静态录制 - 重复执行” 机制，录制阶段会固化操作依赖、资源关联，
运行阶段则按固化逻辑批量执行，不支持动态资源行为；而多数灵活的资源管理方案（如事件池、异步销毁）的
核心是 “动态性”，这与 CUDA 图的 “静态性” 直接冲突。

1. 基于事件的资源池（如显存 / 流池）

CUDA 图录制时，会 “捕获” 事件的当前状态（如未完成 / 已完成），但运行阶段事件的动态状态
（比如池化复用导致事件被其他流程触发）无法被图感知；

图执行是批量异步的，池化资源的 “借 / 还” 依赖事件的实时同步，而图内操作的时序是固化的，会导致资源分配错乱
（比如图执行时，池以为资源可用，但实际被其他流程占用）；

极端情况下，图录制阶段若捕获了 “事件等待” 操作，运行时该事件可能已被池复用，直接导致图执行卡死或资源冲突。

2. 同步创建、异步销毁的资源方案

这类方案（比如先同步 alloc 显存，用完后异步 free）的核心是 “创建 / 销毁时序解耦”，不兼容的原因：

（1）CUDA 图要求录制时确定所有资源的生命周期：图内操作依赖的资源，必须在图执行全程有效；而异步销毁会导致
“图还在执行，资源已被销毁”—— 因为图执行是异步的，销毁操作可能插队到图执行中间，引发非法访问；

（2）同步创建的资源会被图 “绑定”，但异步销毁的操作无法被图捕获（图只能捕获录制时的操作），运行时图执行与
销毁操作无依赖关系，导致竞态；

（3）若销毁后资源被复用（比如重新 alloc），图执行时会访问到新资源，而非录制时绑定的原资源，引发数据错误。
```

由于资源的指针或句柄不固定，需要间接引用或更新图，而且每次提交工作时都需要同步的CPU代码，所以这些方案在CUDA图中难以实现。
如果库的调用者不知道这些考虑因素，并且由于在捕获过程中使用了不允许的API，那么它们也无法用于流捕获。存在多种解决方案，
例如向调用者公开资源。CUDA用户对象则提供了另一种方法。

CUDA 用户对象将用户指定的析构函数回调与内部引用计数相关联，类似于 C++ 的 ```shared_ptr```。引用可由 CPU 上的用户代码和 CUDA 图拥有。
请注意，对于用户拥有的引用，与 C++ 智能指针不同，不存在表示引用的对象；用户必须手动跟踪用户拥有的引用。一个典型的用例是在创建用户对象后，
立即将唯一的用户拥有的引用移至 CUDA 图。

```
CUDA 用户对象（User Object）的设计核心是引用计数 + 自定义析构回调，类比 C++ shared_ptr 但有显著差异，核心要点拆解如下：

1. 与 shared_ptr 的相似性

（1）底层都是引用计数机制：当引用计数归 0 时，自动触发析构逻辑（shared_ptr 调用对象析构函数，CUDA 用户对象调用用
户注册的回调函数）；

（2）引用可被多持有者共享（CPU 代码、CUDA 图均可持有引用），保证对象在所有持有者用完前不被销毁；

2. 与 shared_ptr 的关键差异

C++ shared_ptr 是 “具象的智能指针对象”—— 每个 shared_ptr 实例本身就代表一个引用，拷贝 / 销毁 shared_ptr 会自动增减
引用计数，用户无需手动管理；

而 CUDA 用户对象：

（1）无 “代表引用的对象”：CPU 侧用户代码持有的引用是 “抽象的”，CUDA 不提供类似 shared_ptr 的封装类型；

（2）必须手动跟踪：用户需自己记录 “当前持有多少引用”，并手动调用 API（如 cudaUserObjectRelease）释放引用，
否则会导致内存泄漏或野指针；

3. 典型用例的逻辑（移唯一引用到 CUDA 图）

（1）第一步：创建 CUDA 用户对象时，系统初始化引用计数为 1（这是 “用户拥有的唯一引用”）；

（2）第二步：将该引用 “移交” 给 CUDA 图（通过 API 将用户对象关联到图，CUDA 图会持有这个引用，引用计数不变 / 递增，
取决于 API 设计）；

（3）第三步：用户立即释放自己持有的那 1 个引用（手动调用释放 API），此时引用计数的持有者仅剩 CUDA 图；

（4）最终效果：CUDA 图成为唯一持有者，当图被销毁 / 执行完毕且无其他引用时，自动触发用户注册的析构回调，释放对象资源。
```

```C++
cudaGraph_t graph;
Object *object = new Object;    // 可能具有非平凡析构函数的 C++ 对象
```

子图节点中的图所拥有的引用与子图相关联，而非父图。如果子图被更新或删除，这些引用也会相应地发生变化。如果可执行图或子图通过
```cudaGraphExecUpdate``` 或 ```cudaGraphExecChildGraphNodeSetParams```进行更新，新源图中的引用会被克隆并替换目标图
中的引用。在上述任何一种情况下，如果之前的启动未同步，所有本应被释放的引用都会被保留，直到这些启动执行完毕。

用户对象通过```cudaUserObjectCreate```创建，这是浏览相关API的一个良好起点。
