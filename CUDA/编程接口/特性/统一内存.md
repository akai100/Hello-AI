
统一内存编程有四种范式：

+ 完全支持显式托管内存分配;

+ 全面支持所有具有软件一致性的分配

+ 完全支持所有具有硬件一致性的分配

+ 有限的统一内存支持

## 1. 具有完整CUDA统一内存支持的设备上的统一内存


### 1.1 统一内存：深入示例

具有完整CUDA统一内存支持的系统（参见表统一内存范式概述）允许设备访问与该设备交互的主机进程所拥有的任何内存。

```c++
__global__ void kernel(const char* type, const char* data) {
    static const int n_char = 8;
    printf("%s - first %d characters: '", type, n_char);
    for (int i = 0; i < n_char; ++i) printf("%c", data[i]);
    printf("\n");
}
```

**1. Malloc**

```c++
void test_malloc()
{
    const char test_string[] = "Hello World";
    char* heap_data = (char *)malloc(sizeof(test_string));
    strncpy(heap_data, test_string, sizeof(test_string));
    kernel<<<1, 1>>>("malloc", head_data);
    free(heap_data);
}
```

**2. Managed**

```c++
void test_managed()
{
    const char test_string[] = "Hello World";
    char* data;
    cudaMallocManaged(&data, sizeof(test_string));
    strncpy(data, test_string, sizeof(test_string));
    kernel<<<1, 1>>>("managed", data);
    cudaFree(data);
}
```

**3. 栈变量**

```c++
void test_stack() {
  const char test_string[] = "Hello World";
  kernel<<<1, 1>>>("stack", test_string);
  ASSERT(cudaDeviceSynchronize() == cudaSuccess,
    "CUDA failed with '%s'", cudaGetErrorString(cudaGetLastError()));
}
```

请注意，对于外部变量，它可能由第三方库声明、拥有并管理其内存，而该第三方库完全不与CUDA交互。

还要注意，**栈变量**以及**文件作用域**和**全局作用域变量****只能由GPU通过指针访问**。在这个特定示例中，这很方便，因为字符数组已经被声明为指针：```const char*```。不过，请考虑以下具有全局作用域整数的示例：

#### 1.1.1 文件支持的统一内存

由于完全支持CUDA统一内存的系统允许设备访问主机进程拥有的任何内存，因此它们可以直接访问文件支持的内存。

#### 1.1.2 使用统一内存的进程间通信（IPC）
